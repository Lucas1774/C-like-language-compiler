package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario
action code {:
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	public SymbolIF checkIfExistsSymbolWithinOpenScopes (Token token, boolean iWantIt){
		if (iWantIt && !scopeManager.containsSymbol(token.getLexema())){
			semanticErrorManager.semanticFatalError("Linea " + token.getLine() + " Columna " + token.getColumn() + " identificador " + token.getLexema() + " no declarado");
		} else if (!iWantIt && scopeManager.containsSymbol(token.getLexema())){
			semanticErrorManager.semanticFatalError("Linea " + token.getLine() + " Columna " + token.getColumn() + " identificador " + token.getLexema() + " ya declarado");
		} else if (iWantIt && scopeManager.containsSymbol(token.getLexema())){
			return scopeManager.searchSymbol(token.getLexema());
		}
		return null;
	}

	public TypeIF checkIfExistsTypeWithinOpenScopes (Token token, boolean iWantIt){
		if (iWantIt && !scopeManager.containsType(token.getLexema())){
			semanticErrorManager.semanticFatalError("Linea " + token.getLine() + " Columna " + token.getColumn() + " identificador " + token.getLexema() + " no declarado");
		} else if (!iWantIt && scopeManager.containsType(token.getLexema())){
			semanticErrorManager.semanticFatalError("Linea " + token.getLine() + " Columna " + token.getColumn() + " identificador " + token.getLexema() + " ya declarado");
		} else if (iWantIt && scopeManager.containsType(token.getLexema())){
			return scopeManager.searchType(token.getLexema());
		}
		return null;
	}

	public void checkIfContainsReturn(ArrayList<Sentencia> list, String line){
		for (int i = 0; i < list.size(); i++){
			if (list.get(i).getType().contains("DEVUELVE")){
				return;
			}
		}
		semanticErrorManager.semanticFatalError("Linea " + line + " falta sentencia devuelve");
	}

	public void checkIfReturnTypesMatch(ArrayList<Sentencia> list, String type, String line){
		for (int i = 0; i < list.size(); i++){
			if (list.get(i).getType().contains("DEVUELVE")){
				if (!list.get(i).getType().contains(type)){
					semanticErrorManager.semanticFatalError("Linea " + line + " tipo de funcion " + type + " no coincide con tipo de retorno " + list.get(i).getType());
				}
			}
		}
	}

	public Expresion addIntermeidateCodeToArithmeticExpresion(Expresion result, Expresion operand1, Expresion operand2, String operation){
		TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
		TemporalIF temp = tf.create();
		cb.addQuadruples(operand1.getIntermediateCode());
		cb.addQuadruples(operand2.getIntermediateCode());
		cb.addQuadruple(operation, temp, operand1.getTemporal(), operand2.getTemporal());
		result.setTemporal(temp);
		result.setIntermediateCode(cb.create());
		return result;
	}

	public Expresion addIntermediateCodeToBooleanExpresion(Expresion result, Expresion operand1, Expresion operand2, String operation){
		TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
		TemporalIF temp = tf.create();
		cb.addQuadruples(operand1.getIntermediateCode());
		cb.addQuadruples(operand2.getIntermediateCode());
		cb.addQuadruple(operation, temp, getCBooleanOfInt(operand1.getTemporal()), getCBooleanOfInt(operand2.getTemporal()));
		result.setTemporal(temp);
		result.setIntermediateCode(cb.create());
		return result;
	}
	public int getCBooleanOfInt(Object a) {
		if ((int)a > 0){
			return 1;
		}
		return 0;
	}
:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();

	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}

	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales
terminal Token PLUS;
terminal Token AUTO_INCREMENTO;
terminal Token MULT;
terminal Token AND_LOGICA;
terminal Token OPEN_BRACKET;
terminal Token CLOSE_BRACKET;
terminal Token OPEN_PARENTHESIS;
terminal Token CLOSE_PARENTHESIS;
terminal Token OPEN_KEY;
terminal Token CLOSE_KEY;
terminal Token SEMI_COLON;
terminal Token COLON;
terminal Token TWO_POINTS;
terminal Token NEGACION;
terminal Token EQUAL;
terminal Token ASSIGN_SUMA;
terminal Token ASSIGN;
terminal Token LOWER_THAN;
terminal Token CASO;
terminal Token CONSTANTE;
terminal Token CORTE;
terminal Token ENTERO;
terminal Token ESCRIBE;
terminal Token ESCRIBE_ENT;
terminal Token ALTENATIVAS;
terminal Token MIENTRAS;
terminal Token PORDEFECTO;
terminal Token principal;
terminal Token DEVUELVE;
terminal Token SI;
terminal Token SINO;
terminal Token TIPO;
terminal Token VACIO;
terminal Token IDENTIFICADOR;
terminal Token NUMERO;
terminal Token STRING;

// Declaracion de no terminales
non terminal program;
non terminal Axiom axiom;
non terminal Axiom1 axiom1;
non terminal Id1 id1;
non terminal ArrayList<Sentencia> funcion1;
non terminal funcionPrincipal;
non terminal ArrayList<Sentencia> funcionPrincipal1;
non terminal epsilon;
non terminal seccionFunciones;
non terminal funcion;
non terminal ArrayList<Parametro> seccionParametros;
non terminal ArrayList<Parametro> declaracionParametros;
non terminal Parametro parametro;
non terminal ArrayList<DeclaracionConstante> seccionConstantes;
non terminal DeclaracionConstante declaracionConstante;
non terminal ArrayList<DeclaracionTipo> seccionTipos;
non terminal DeclaracionTipo declaracionTipo;
non terminal TamTipo tamTipo;
non terminal ArrayList<DeclaracionVariable> seccionVariables;
non terminal DeclaracionVariable declaracionVariable;
non terminal ArrayList<Id> listadoIDs1;
non terminal ArrayList<Id> listadoIDs;
non terminal Id id;
non terminal Expresion expresion;
non terminal AccesoVector accesoVector;
non terminal String llamadaFuncion;
non terminal Sentencia bloque;
non terminal bloque1;
non terminal ArrayList<Sentencia> listadoSentencias;
non terminal Sentencia sentencia;
non terminal Sentencia sentenciaIncremento;
non terminal Sentencia sentenciaAsignacion;
non terminal Referencia ref;
non terminal Sentencia sentenciaAsignacionSuma;
non terminal Sentencia sentenciaSi;
non terminal Sentencia sentenciaAlternativas;
non terminal casosAlternativa;
non terminal casoAlt; 
non terminal porDefecto;
non terminal Sentencia sentenciaMientras;
non terminal Sentencia sentenciaLlamadaFuncion;
non terminal ArrayList<Expresion> parametros;
non terminal Sentencia sentenciaSalida;
non terminal opcionesEscribe;
non terminal Expresion opcionesEscribeEnt;
non terminal Sentencia sentenciaDevuelve;

// Declaracion de relaciones de precedencia
precedence left     AND_LOGICA;
precedence left		EQUAL;
precedence left		LOWER_THAN;
precedence left		PLUS;
precedence left		MULT;
precedence left		AUTO_INCREMENTO, NEGACION;
precedence right	OPEN_BRACKET, CLOSE_BRACKET;
precedence left 	OPEN_KEY, CLOSE_KEY;
precedence nonassoc SINO;
precedence nonassoc SI;

// Declaracion de reglas de produccion
start with program;

epsilon ::= ;

program ::= 
{: 
    syntaxErrorManager.syntaxInfo ("Starting parsing...");
:}
	axiom:ax
	{:   		
		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
		
		//List intermediateCode = ax.getIntermediateCode ();
		//finalCodeFactory.create (intermediateCode);

		// En caso de no comentarse las dos sentencias anteriores se puede generar una excepcion
		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
		// aún no se tendrá implementada la generación de código intermedio ni final.
		// Para la entrega final deberán descomentarse y usarse.

		List<ScopeIF> scopesList = scopeManager.getAllScopes();
		for (int j = 0; j < scopesList.size(); j++){
			ScopeIF current = scopesList.get(j);
			List myList = new ArrayList<TypeIF>(current.getTypeTable().getTypes());
			for (int i = 0; i < myList.size(); i++){
				syntaxErrorManager.syntaxInfo(myList.get(i).toString());
			}
			List myList2 = new ArrayList<SymbolIF>(current.getSymbolTable().getSymbols()); 
			for (int i = 0; i < myList2.size(); i++){
				syntaxErrorManager.syntaxInfo(myList2.get(i).toString());
			}
		}
		scopeManager.closeScope();
		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
	:};

axiom ::= {:
	scopeManager.openScope("global");
	scopeManager.getCurrentScope().getTypeTable().addType(new TypeProcedure(scopeManager.getCurrentScope(), "vacio"));
	scopeManager.getCurrentScope().getTypeTable().addType(new TypeSimple(scopeManager.getCurrentScope(), "entero"));
:}
	seccionConstantes:listaDeclaracionesConstantes seccionTipos:listaDeclaracionesTipos axiom1:a;

axiom1 ::= seccionVariables:listaDeclaracionesVariables seccionFunciones  | seccionFunciones {:

:};

seccionConstantes ::= declaracionConstante seccionConstantes
	| epsilon;     
                      
declaracionConstante ::= CONSTANTE IDENTIFICADOR:name NUMERO:value SEMI_COLON {:
	checkIfExistsSymbolWithinOpenScopes(name, false);
	SymbolConstant newSymbol = new SymbolConstant(scopeManager.getCurrentScope(), name.getLexema(), scopeManager.searchType("entero"), Integer.parseInt(value.getLexema()));
	scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
:};

seccionTipos ::= declaracionTipo seccionTipos
	| epsilon;
                      
declaracionTipo ::= TIPO ENTERO IDENTIFICADOR:identifier OPEN_BRACKET tamTipo:tamTipo CLOSE_BRACKET SEMI_COLON {:
	checkIfExistsTypeWithinOpenScopes(identifier, false);
	TypeArray typeArray = new TypeArray(scopeManager.getCurrentScope(), identifier.getLexema(), (int)tamTipo.getValue());
	scopeManager.getCurrentScope().getTypeTable().addType(typeArray);
:};

tamTipo ::= NUMERO:n {:
	if (Integer.parseInt(n.getLexema()) <= 0){ // if it is not positive
		semanticErrorManager.semanticFatalError("Linea " + n.getLine() + " Columna " + n.getColumn() + " valor " + n.getLexema() + " fuera del rango");
	}
	TamTipo tamTipo = new TamTipo(Integer.parseInt(n.getLexema()));
	RESULT = tamTipo;
:}
	| IDENTIFICADOR:s {:
		SymbolIF symbol = checkIfExistsSymbolWithinOpenScopes(s, true);
		if (!(symbol instanceof SymbolConstant)){ // if it is not a constant)
			semanticErrorManager.semanticFatalError("Linea " + s.getLine() + " Columna " + s.getColumn() + " identificador " + s.getLexema() + " no hace referencia a una constante");
		}
		int value = ((SymbolConstant)symbol).getValue();
		if (value <= 0){ // if it is a constant (and thus an integer) but 0
			semanticErrorManager.semanticFatalError("Linea " + s.getLine() + " Columna " + s.getColumn() + " valor " + s.getLexema() + " debe ser positivo");
		}
		TamTipo tamTipo = new TamTipo(value);
		RESULT = tamTipo;
	:};

seccionVariables ::= seccionVariables:dvs declaracionVariable:dv {:
	dvs.add(dv);
	RESULT = dvs;
:}
	| declaracionVariable{:
		ArrayList<DeclaracionVariable> dvs = new ArrayList<DeclaracionVariable>();
		RESULT = dvs;
	:};

declaracionVariable ::= ENTERO:identifier listadoIDs:list SEMI_COLON {:
	for (int i = 0; i < list.size(); i++){
		SymbolVariable newSymbol =	new SymbolVariable(scopeManager.getCurrentScope(), list.get(i).getName(), scopeManager.searchType("entero"));
		scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
	}
	DeclaracionVariable dv = new DeclaracionVariable ("entero", list);
	RESULT = dv;
:}
	| IDENTIFICADOR:identifier listadoIDs:list SEMI_COLON {:
		TypeIF type = checkIfExistsTypeWithinOpenScopes(identifier, true);
		for (int i = 0; i < list.size(); i++){
			if (list.get(i).hasAssignmentValue()){ // if is being tried to be assigned
				semanticErrorManager.semanticFatalError("Linea " + identifier.getLine() + " " + list.get(i).getName() + " no puede ser inicializado");
			}
			SymbolVariable newSymbol = new SymbolVariable(scopeManager.getCurrentScope(), list.get(i).getName(), type);
			scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
		}
		DeclaracionVariable dv = new DeclaracionVariable (type.getName(), list);
		RESULT = dv;
	:};
                      
listadoIDs ::= id:fullDeclaration listadoIDs1:restOfDeclarations {:
	restOfDeclarations.add(fullDeclaration);
	RESULT = restOfDeclarations;
:};

listadoIDs1 ::= COLON listadoIDs:list {:
	RESULT = list;
:}
	| epsilon {:
		ArrayList<Id> emptyList = new ArrayList();
		RESULT = emptyList;
	:};

id ::= IDENTIFICADOR:identifier id1:declaration {:
	checkIfExistsSymbolWithinOpenScopes(identifier, false);
	Id fullDeclaration = new Id (identifier.getLexema(), declaration.hasAssignmentValue(), declaration.getValue());
	RESULT = fullDeclaration;
:};

id1 ::= epsilon {:
	Id1 declaration = new Id1(false, 0);
	RESULT = declaration;
:}
    | ASSIGN NUMERO:n {:
		Id1 declaration = new Id1(true, Integer.parseInt(n.getLexema()));
		RESULT = declaration;
	:};

seccionFunciones ::= funcion seccionFunciones
                      | funcionPrincipal;
                      
funcion ::= VACIO IDENTIFICADOR:identifier  OPEN_KEY seccionParametros:params CLOSE_KEY {:
	checkIfExistsSymbolWithinOpenScopes(identifier,  false);
	SymbolProcedure newSymbol = new SymbolProcedure(scopeManager.getCurrentScope(), identifier.getLexema(), scopeManager.searchType("vacio"), params);
	scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
:}
OPEN_PARENTHESIS {:
	scopeManager.openScope();
	for (int i = 0; i < params.size(); i++){
		TypeIF type = params.get(i).getType();
		SymbolParameter<?> newSymbol = new SymbolParameter<>(scopeManager.getCurrentScope(), params.get(i).getName(), params.get(i).getType(), null);
		scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
	}
:}
seccionTipos funcion1:list {:
	checkIfReturnTypesMatch(list, "VACIO", Integer.toString(identifier.getLine()));
:}
	| ENTERO IDENTIFICADOR:identifier  OPEN_KEY seccionParametros:params CLOSE_KEY {:
		checkIfExistsSymbolWithinOpenScopes(identifier, false);
		SymbolFunction newSymbol = new SymbolFunction(scopeManager.getCurrentScope(), identifier.getLexema(), scopeManager.searchType("entero"), params);
		scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
	:}
	OPEN_PARENTHESIS {:
		scopeManager.openScope();
		for (int i = 0; i < params.size(); i++){
			TypeIF type = params.get(i).getType();
			SymbolParameter<?> newSymbol = new SymbolParameter<>(scopeManager.getCurrentScope(), params.get(i).getName(), params.get(i).getType(), null);
			scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
		}
	:}
seccionTipos funcion1:list {:
	checkIfReturnTypesMatch(list, "entero", Integer.toString(identifier.getLine()));
:};
               
funcion1 ::= listadoSentencias:list CLOSE_PARENTHESIS:p {:
	checkIfContainsReturn(list, Integer.toString(p.getLine()));
	scopeManager.closeScope();
	RESULT = list;
:}
  | seccionVariables listadoSentencias:list CLOSE_PARENTHESIS:p {:
		checkIfContainsReturn(list, Integer.toString(p.getLine()));
		scopeManager.closeScope();
		RESULT = list;
	:};

seccionParametros ::= declaracionParametros:params {:
	RESULT = params;
:} 
	| epsilon {:
		ArrayList<Parametro> params = new ArrayList();
		RESULT = params;
	:};

declaracionParametros ::= parametro:param {:
	ArrayList<Parametro> params = new ArrayList();
	params.add(param);
	RESULT = params;
:}
	| parametro:param COLON declaracionParametros:params {:
		params.add(param);
		RESULT = params;
	:};

parametro ::= ENTERO IDENTIFICADOR:name {:
	Parametro param = new Parametro(scopeManager.searchType("entero"), name.getLexema());
	RESULT = param;
:}
	| IDENTIFICADOR:identifier IDENTIFICADOR:name {:
		TypeIF type = checkIfExistsTypeWithinOpenScopes(identifier, true);
		Parametro param = new Parametro(type, name.getLexema());
		RESULT = param;
	:};

funcionPrincipal ::= VACIO principal:p OPEN_KEY CLOSE_KEY OPEN_PARENTHESIS {:
	scopeManager.openScope("main");
:}

funcionPrincipal1:list {:
	checkIfContainsReturn(list, Integer.toString(p.getLine()));
	checkIfReturnTypesMatch(list, "VACIO", Integer.toString(p.getLine()));
	SymbolProcedure newSymbol = new SymbolProcedure(scopeManager.getCurrentScope(), p.getLexema(), scopeManager.searchType("vacio"), new ArrayList<Parametro>());
	scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
:};

funcionPrincipal1 ::= seccionVariables listadoSentencias:list CLOSE_PARENTHESIS {:
	scopeManager.closeScope();
	RESULT = list;
:}
	| listadoSentencias:list CLOSE_PARENTHESIS {:
		scopeManager.closeScope();
		RESULT = list;
	:};


// EXPRESIONES

expresion ::= NUMERO:n {:
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	cb.addQuadruple("MV", temp, new Value(Integer.parseInt(n.getLexema())));
	Expresion e = new Expresion(scopeManager.searchType("entero"), "constante", Integer.parseInt(n.getLexema()));
	e.setIntermediateCode(cb.create());
	e.setTemporal(temp);
	semanticErrorManager.semanticDebug("Codigo intermedio: " + e.getIntermediateCode());
	RESULT = e;
:}
	| IDENTIFICADOR:id {:
		SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
		String subTipo = mySymbol instanceof SymbolConstant ? "constante" : "variable";
		Object value = subTipo.equals("constante") ? ((SymbolConstant)mySymbol).getValue() : null;

		TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
		TemporalIF temp = tf.create();
		if (mySymbol instanceof SymbolConstant){
			cb.addQuadruple("MV", temp, new Value(value));
		} else{
			cb.addQuadruple("MV", temp, new Variable(id.getLexema(), mySymbol.getScope()));
		}
		Expresion e = new Expresion(mySymbol.getType(), subTipo, value);
		e.setTemporal(temp);
		e.setIntermediateCode(cb.create());
		semanticErrorManager.semanticDebug("Codigo intermedio: " + e.getIntermediateCode());
		RESULT = e;
	:}
		|  OPEN_KEY expresion:e CLOSE_KEY {:
			RESULT = e;
		:}
			|  expresion:a PLUS:p expresion:b {:
				if (!a.getType().getName().equals("entero") || !b.getType().getName().equals("entero")){
					semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresiones deben ser de tipo int");
				}
				String subTipo = a.getSubType().equals("constante") && b.getSubType().equals("constante") ? "constante" : "variable";
				Object value = subTipo.equals("constante") ? Integer.parseInt(a.getValue().toString()) + Integer.parseInt(b.getValue().toString()) : null;
				Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
				RESULT = e;
				addIntermeidateCodeToArithmeticExpresion(e, a, b, "ADD");
				semanticErrorManager.semanticDebug("Codigo intermedio: " + e.getIntermediateCode());
			:}
				|  expresion:a MULT:p expresion:b {:
					if (!a.getType().getName().equals("entero") || !b.getType().getName().equals("entero")){
						semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresiones deben ser de tipo int");
					}
					String subTipo = a.getSubType().equals("constante") && b.getSubType().equals("constante") ? "constante" : "variable";
					Object value = subTipo.equals("constante") ? Integer.parseInt(a.getValue().toString()) * Integer.parseInt(b.getValue().toString()) : null;
					Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
					addIntermeidateCodeToArithmeticExpresion(e, a, b, "MUL");
					semanticErrorManager.semanticDebug("Codigo intermedio: " + e.getIntermediateCode());
					RESULT = e;
				:} 
					|  expresion:a AUTO_INCREMENTO:p {:
						if (!a.getType().getName().equals("entero")){
							semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresion debe ser de tipo int");
						}
						String subTipo = a.getSubType().equals("constante") ? "constante" : "variable";
						Object value = subTipo.equals("constante") ? Integer.parseInt(a.getValue().toString()) + 1 : null;
						TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
						TemporalIF temp = tf.create();
						Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
						cb.addQuadruples(a.getIntermediateCode());
						cb.addQuadruple("ADD", temp, a.getTemporal(), 1);
						e.setTemporal(temp);
						e.setIntermediateCode(cb.create());
						semanticErrorManager.semanticDebug("Codigo intermedio: " + e.getIntermediateCode());
						RESULT = e;
					:} 
						|  NEGACION:p expresion:a {:
							if (!a.getType().getName().equals("entero")){
								semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresion debe ser de tipo int");
							}
							String subTipo = a.getSubType().equals("constante") ? "constante" : "variable";
							Object value;
							if (subTipo.equals("constante")){
								value = Integer.parseInt(a.getValue().toString()) == 0 ? 1 : 0;
							} else {
								value = null;
							}
							TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
							TemporalIF temp = tf.create();
							Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
							cb.addQuadruples(a.getIntermediateCode());
							cb.addQuadruple("NOT", temp, getCBooleanOfInt(a.getTemporal()));
							e.setTemporal(temp);
							e.setIntermediateCode(cb.create());
							semanticErrorManager.semanticDebug("Codigo intermedio: " + e.getIntermediateCode());
							RESULT = e;
						:}
							|  expresion:a LOWER_THAN:p expresion:b {:
								if (!a.getType().getName().equals("entero") || !b.getType().getName().equals("entero")){
									semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresiones deben ser de tipo int");
								}
								String subTipo = a.getSubType().equals("constante") && b.getSubType().equals("constante") ? "constante" : "variable";
								Object value;
								if (subTipo.equals("constante")){
									value = Integer.parseInt(a.getValue().toString()) < Integer.parseInt(b.getValue().toString()) ? 1 : 0;
								} else {
									value = null;
								}
								Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
								addIntermediateCodeToBooleanExpresion(e, a, b, "LS");
								semanticErrorManager.semanticDebug("Codigo intermedio: " + e.getIntermediateCode());
								RESULT = e;
							:}
								|  expresion:a EQUAL:p expresion:b {:
									if (!a.getType().getName().equals("entero") || !b.getType().getName().equals("entero")){
										semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresiones deben ser de tipo int");
									}
									String subTipo = a.getSubType().equals("constante") && b.getSubType().equals("constante") ? "constante" : "variable";
									Object value;
									if (subTipo.equals("constante")){
										value = Integer.parseInt(a.getValue().toString()) == Integer.parseInt(b.getValue().toString()) ? 1 : 0;
									} else {
										value = null;
									}
									Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
									addIntermediateCodeToBooleanExpresion(e, a, b, "EQ");
									semanticErrorManager.semanticDebug("Codigo intermedio: " + e.getIntermediateCode());
									RESULT = e;
								:}
									|  expresion:a AND_LOGICA:p expresion:b {:
										if (!a.getType().getName().equals("entero") || !b.getType().getName().equals("entero")){
											semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresiones deben ser de tipo int");
										}
										String subTipo = a.getSubType().equals("constante") && b.getSubType().equals("constante") ? "constante" : "variable";
										Object value;
										if (subTipo.equals("constante")){
											value = Integer.parseInt(a.getValue().toString()) < Integer.parseInt(b.getValue().toString()) ? 1 : 0;
										} else {
											value = null;
										}
										Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
										addIntermediateCodeToBooleanExpresion(e, a, b, "AND");
										semanticErrorManager.semanticDebug("Codigo intermedio: " + e.getIntermediateCode());
										RESULT = e;
									:}
										|  accesoVector:a {:
											Expresion e = new Expresion(scopeManager.searchType("entero"), "variable", null);
										:}
											|  llamadaFuncion:name {:
												SymbolIF mySymbol = scopeManager.searchSymbol(name);
												Expresion e = new Expresion(mySymbol.getType(), "variable", null);
												RESULT = e;
											:};

accesoVector ::= IDENTIFICADOR:id OPEN_BRACKET expresion:a  CLOSE_BRACKET {:
	SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
	if (!(mySymbol.getType() instanceof TypeArray)){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " identificador " + mySymbol.getName() + " no es un vector");
	}
	if (!a.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " expresion indice debe ser de tipo int");
	}
	if (a.getSubType().equals("constante")){
		int maxLength = ((TypeArray)mySymbol.getType()).getLength();
		int index = (int)a.getValue();
		if (index < 0 || index >= maxLength){
			semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " expresion con valor " + index +" fuera de rango [0-" + (maxLength - 1) + "]");
		}
	}
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	TemporalIF temp1 = tf.create();
	TemporalIF temp2 = tf.create();
	Expresion e = new Expresion(scopeManager.searchType("entero"), "variable", null);
	TemporalIF tempPosicion = a.getTemporal(); 
	SymbolIF symbolVariable = scopeManager.searchSymbol(id.getLexema());
	Variable var = new Variable(id.getLexema(), symbolVariable.getScope());
	cb.addQuadruple("MVA", temp1, var);
	cb.addQuadruple("ADD", temp2, temp1, tempPosicion); 
	cb.addQuadruple("MVP", temp, temp2);
	e.setTemporal(temp);
	e.setIntermediateCode (cb.create());
	semanticErrorManager.semanticDebug("Codigo intermedio: " + e.getIntermediateCode());
	AccesoVector accesoVector = new AccesoVector (id.getLexema(), (int)a.getValue());
	RESULT = accesoVector;
:};

sentenciaLlamadaFuncion ::= llamadaFuncion SEMI_COLON;

llamadaFuncion ::= IDENTIFICADOR:id OPEN_KEY parametros:list CLOSE_KEY {:
	SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
	if (!(mySymbol instanceof SymbolFunction) && (!(mySymbol instanceof SymbolProcedure))){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " identificador " + mySymbol.getName() + " no es una funcion");
	}
	ArrayList<Parametro> listaOriginal = new ArrayList();
	if (mySymbol instanceof SymbolFunction){
		listaOriginal = ((SymbolFunction)mySymbol).getParameters();
	} else {
		listaOriginal = ((SymbolProcedure)mySymbol).getParameters();
	}
	if (listaOriginal.size() != list.size()){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " funcion " + mySymbol.getName() + " parametros esperados " + listaOriginal.size() + " parametros obtenidos " + list.size());
	}
	for (int i = 0; i < list.size(); i++){
		if (!list.get(i).getType().getName().equals(listaOriginal.get(i).getType().getName())){
			semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " funcion " + mySymbol.getName() + " parametro " + (list.size() - i) + " tipo esperado " + listaOriginal.get(i).getType().getName() + " tipo obtenido " + list.get(i).getType().getName());
		}
	}
	RESULT = id.getLexema();
:}
	| IDENTIFICADOR:id OPEN_KEY CLOSE_KEY {:
		SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
		if (!(mySymbol instanceof SymbolFunction) && (!(mySymbol instanceof SymbolProcedure))){
			semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " identificador " + mySymbol.getName() + " no es una funcion");
		}
		ArrayList<Parametro> listaOriginal = new ArrayList();
		if (mySymbol instanceof SymbolFunction){
			listaOriginal = ((SymbolFunction)mySymbol).getParameters();
		} else {
			listaOriginal = ((SymbolProcedure)mySymbol).getParameters();
		}
		if (listaOriginal.size() != 0){
			semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " funcion " + mySymbol.getName() + " parametros esperados " + listaOriginal.size() + " parametros obtenidos " + "0" );
		}
		RESULT = id.getLexema();
	:};

parametros ::= expresion:e {:
	ArrayList<Expresion> list = new ArrayList<Expresion>();
	list.add(e);
	RESULT = list;
:} 
	| expresion:e COLON parametros:list {:
		list.add(e);
		RESULT = list;	
	:};

//  SENTENCIAS

bloque ::= OPEN_PARENTHESIS {:
	scopeManager.openScope();
:} bloque1;

bloque1 ::= seccionVariables listadoSentencias CLOSE_PARENTHESIS {:
	scopeManager.closeScope();
:}
	| listadoSentencias CLOSE_PARENTHESIS {:
		scopeManager.closeScope();
	:};

listadoSentencias ::= listadoSentencias:list sentencia:s {:
	list.add(s);
	RESULT = list;
:}
	| sentencia:s {:
		ArrayList<Sentencia> list= new ArrayList<Sentencia>();
		list.add(s);
		RESULT = list;
	:};

sentencia ::= sentenciaDevuelve:sentencia {:
	RESULT = sentencia;
:}
	| sentenciaIncremento {:
		Sentencia sentencia = new Sentencia ("INCREMENTO");
		RESULT = sentencia;
	:}
		| sentenciaAsignacion:sentencia {:
			RESULT = sentencia;
		:}
			| sentenciaAsignacionSuma:sentencia {:
				RESULT = sentencia;
			:}
				| sentenciaSi {:
					Sentencia sentencia = new Sentencia ("SI");
					RESULT = sentencia;
				:}
					| sentenciaAlternativas {:
						Sentencia sentencia = new Sentencia ("ALTERNATIVAS");
						RESULT = sentencia;
					:}
						| sentenciaMientras {:
							Sentencia sentencia = new Sentencia ("MIENTRAS");
							RESULT = sentencia;
						:}
							| sentenciaLlamadaFuncion {:
								Sentencia sentencia = new Sentencia ("LLAMADAFUNCION");
								RESULT = sentencia;
							:}
								| sentenciaSalida {:
									Sentencia sentencia = new Sentencia ("SALIDA");
									RESULT = sentencia;
								:}
									| bloque {:
										Sentencia sentencia = new Sentencia ("BLOQUE");
										RESULT = sentencia;
									:};

sentenciaDevuelve ::= DEVUELVE SEMI_COLON {:
	Sentencia sentencia = new Sentencia ("DEVUELVE_VACIO");
	RESULT = sentencia;
:}
	| DEVUELVE expresion:e SEMI_COLON {:	
		Sentencia sentencia = new Sentencia ("DEVUELVE_" + e.getType().getName());
		RESULT = sentencia;
	:};

sentenciaIncremento ::= IDENTIFICADOR:id AUTO_INCREMENTO SEMI_COLON {:
	SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
	if (!mySymbol.getType().getName().equals("entero")) {
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " +id.getColumn() + " no se puede aplicar autoincremento a objeto no de tipo entero");
	}
:};

sentenciaAsignacion ::= ref:reference ASSIGN:a expresion:e SEMI_COLON {:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + a.getLine() + " no se puede asignar un " + e.getType().getName() + " a una variable");
	}
	TemporalFactoryIF tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	Sentencia sentencia = new Sentencia("ASIGNACION");
	cb.addQuadruples(e.getIntermediateCode());
	Variable var = new Variable(reference.getName(), scopeManager.searchSymbol(reference.getName()).getScope());
	cb.addQuadruple("MVA", temp, var);
	cb.addQuadruple("STP", temp, e.getTemporal());
	sentencia.setIntermediateCode(cb.create());
	semanticErrorManager.semanticDebug("Codigo intermedio: " + sentencia.getIntermediateCode());
	RESULT = sentencia;
:};

sentenciaAsignacionSuma ::= ref:reference ASSIGN_SUMA:a expresion:e SEMI_COLON {:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + a.getLine() + " no se puede sumar un " + e.getType().getName() + " a una variable");
	}
	TemporalFactoryIF tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	TemporalIF temp1 = tf.create();
	TemporalIF temp2 = tf.create();
	Sentencia sentencia = new Sentencia("ASIGNACION_SUMA");
	cb.addQuadruples(e.getIntermediateCode());
	Variable var = new Variable(reference.getName(), scopeManager.searchSymbol(reference.getName()).getScope());
	// TODO: finish this:
	// cb.addQuadruple("ADD", temp1, ?, e.getTemporal());
	cb.addQuadruple("MVA", temp, var);
	cb.addQuadruple("STP", temp, temp1);
	sentencia.setIntermediateCode(cb.create());
	semanticErrorManager.semanticDebug("Codigo intermedio: " + sentencia.getIntermediateCode());
	RESULT = sentencia;
:};

ref ::= IDENTIFICADOR:id {:
	SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
	if (!mySymbol.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " el objeto " + id.getLexema() + " no es de tipo entero");
	}
	Referencia r = new Referencia(mySymbol.getName(), "IDENTIFICADOR", 0);
	RESULT = r;
:}
	| accesoVector:a {:
		Referencia r = new Referencia(a.getName(), "ACCESO_VECTOR", a.getValue());
		RESULT = r;
	:};

sentenciaSi ::= SI:id OPEN_KEY expresion:e CLOSE_KEY sentencia SINO sentencia {:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " expresion no se puede evaluar a 0 u otro entero");
	}
:}
	| SI:id OPEN_KEY expresion:e CLOSE_KEY sentencia {:
		if (!e.getType().getName().equals("entero")){
			semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " expresion no se puede evaluar a 0 u otro entero");
		}
	:};
	
sentenciaAlternativas ::= ALTENATIVAS:id OPEN_KEY expresion:e {:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " la expresion no se puede evaluar a un entero");
	}
:} CLOSE_KEY OPEN_PARENTHESIS casosAlternativa porDefecto CLOSE_PARENTHESIS;

casosAlternativa ::= casosAlternativa casoAlt | casoAlt;

casoAlt ::= CASO NUMERO TWO_POINTS bloque CORTE SEMI_COLON;

porDefecto ::= PORDEFECTO TWO_POINTS bloque CORTE SEMI_COLON | epsilon; 

sentenciaMientras ::= MIENTRAS:id OPEN_KEY expresion:e {:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " la expresion no se puede evaluar a 0 u otro entero");
	}
:} CLOSE_KEY sentencia;

sentenciaSalida ::= ESCRIBE OPEN_KEY opcionesEscribe CLOSE_KEY SEMI_COLON
	| ESCRIBE_ENT:id OPEN_KEY opcionesEscribeEnt:e {:
		if (!e.getType().getName().equals("entero")){
			semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " la expresion no se puede evaluar a entero");
		}
	:} CLOSE_KEY SEMI_COLON;

opcionesEscribe ::= epsilon | STRING;

opcionesEscribeEnt ::= epsilon | expresion:e {:
	RESULT = e;
:};
