package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario
action code {:
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	public SymbolIF checkIfExistsSymbolWithinOpenScopes (Token token, boolean iWantIt){
		if (iWantIt && !scopeManager.containsSymbol(token.getLexema())){
			semanticErrorManager.semanticFatalError("Linea " + token.getLine() + " Columna " + token.getColumn() + " identificador " + token.getLexema() + " no declarado");
		} else if (!iWantIt && scopeManager.containsSymbol(token.getLexema())){
			semanticErrorManager.semanticFatalError("Linea " + token.getLine() + " Columna " + token.getColumn() + " identificador " + token.getLexema() + " ya declarado");
		} else if (iWantIt && scopeManager.containsSymbol(token.getLexema())){
			return scopeManager.searchSymbol(token.getLexema());
		}
		return null;
	}

	public TypeIF checkIfExistsTypeWithinOpenScopes (Token token, boolean iWantIt){
		if (iWantIt && !scopeManager.containsType(token.getLexema())){
			semanticErrorManager.semanticFatalError("Linea " + token.getLine() + " Columna " + token.getColumn() + " identificador " + token.getLexema() + " no declarado");
		} else if (!iWantIt && scopeManager.containsType(token.getLexema())){
			semanticErrorManager.semanticFatalError("Linea " + token.getLine() + " Columna " + token.getColumn() + " identificador " + token.getLexema() + " ya declarado");
		} else if (iWantIt && scopeManager.containsType(token.getLexema())){
			return scopeManager.searchType(token.getLexema());
		}
		return null;
	}

	public void checkIfContainsReturn(ArrayList<Sentencia> list, String line){
		for (int i = 0; i < list.size(); i++){
			if (list.get(i).getType().contains("DEVUELVE")){
				return;
			}
		}
		semanticErrorManager.semanticFatalError("Linea " + line + " falta sentencia devuelve");
	}

	public void checkIfReturnTypesMatch(ArrayList<Sentencia> list, String type, String line){
		for (int i = 0; i < list.size(); i++){
			if (list.get(i).getType().contains("DEVUELVE")){
				if (!list.get(i).getType().contains(type)){
					semanticErrorManager.semanticFatalError("Linea " + line + " tipo de funcion " + type + " no coincide con tipo de retorno " + list.get(i).getType());
				}
			}
		}
	}
:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();

	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}

	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales
terminal Token PLUS;
terminal Token AUTO_INCREMENTO;
terminal Token MULT;
terminal Token AND_LOGICA;
terminal Token OPEN_BRACKET;
terminal Token CLOSE_BRACKET;
terminal Token OPEN_PARENTHESIS;
terminal Token CLOSE_PARENTHESIS;
terminal Token OPEN_KEY;
terminal Token CLOSE_KEY;
terminal Token SEMI_COLON;
terminal Token COLON;
terminal Token TWO_POINTS;
terminal Token NEGACION;
terminal Token EQUAL;
terminal Token ASSIGN_SUMA;
terminal Token ASSIGN;
terminal Token LOWER_THAN;
terminal Token CASO;
terminal Token CONSTANTE;
terminal Token CORTE;
terminal Token ENTERO;
terminal Token ESCRIBE;
terminal Token ESCRIBE_ENT;
terminal Token ALTENATIVAS;
terminal Token MIENTRAS;
terminal Token PORDEFECTO;
terminal Token principal;
terminal Token DEVUELVE;
terminal Token SI;
terminal Token SINO;
terminal Token TIPO;
terminal Token VACIO;
terminal Token IDENTIFICADOR;
terminal Token NUMERO;
terminal Token STRING;

// Declaracion de no terminales
non terminal program;
non terminal Axiom axiom;
non terminal axiom1;
non terminal Id1 id1;
non terminal ArrayList<Sentencia> funcion1;
non terminal funcionPrincipal;
non terminal ArrayList<Sentencia> funcionPrincipal1;
non terminal epsilon;
non terminal seccionFunciones;
non terminal funcion;
non terminal ArrayList<Parametro> seccionParametros;
non terminal ArrayList<Parametro> declaracionParametros;
non terminal Parametro parametro;
non terminal seccionConstantes;
non terminal DeclaracionConstante declaracionConstante;
non terminal seccionTipos;
non terminal declaracionTipo;
non terminal TamTipo tamTipo;
non terminal seccionVariables;
non terminal declaracionVariable;
non terminal ArrayList<Id> listadoIDs1;
non terminal ArrayList<Id> listadoIDs;
non terminal Id id;
non terminal Expresion expresion;
non terminal Expresion accesoVector;
non terminal String llamadaFuncion;
non terminal Sentencia bloque;
non terminal bloque1;
non terminal ArrayList<Sentencia> listadoSentencias;
non terminal Sentencia sentencia;
non terminal Sentencia sentenciaIncremento;
non terminal Sentencia sentenciaAsignacion;
non terminal String ref;
non terminal Sentencia sentenciaAsignacionSuma;
non terminal Sentencia sentenciaSi;
non terminal Sentencia sentenciaAlternativas;
non terminal casosAlternativa;
non terminal casoAlt; 
non terminal porDefecto;
non terminal Sentencia sentenciaMientras;
non terminal Sentencia sentenciaLlamadaFuncion;
non terminal ArrayList<Expresion> parametros;
non terminal Sentencia sentenciaSalida;
non terminal opcionesEscribe;
non terminal Expresion opcionesEscribeEnt;
non terminal Sentencia sentenciaDevuelve;

// Declaracion de relaciones de precedencia
precedence left     AND_LOGICA;
precedence left		EQUAL;
precedence left		LOWER_THAN;
precedence left		PLUS;
precedence left		MULT;
precedence left		AUTO_INCREMENTO, NEGACION;
precedence right	OPEN_BRACKET, CLOSE_BRACKET;
precedence left 	OPEN_KEY, CLOSE_KEY;
precedence nonassoc SINO;
precedence nonassoc SI;

// Declaracion de reglas de produccion
start with program;

epsilon ::= ;

program ::= 
{: 
    syntaxErrorManager.syntaxInfo ("Starting parsing...");
:}
	axiom:ax
	{:   		
		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
		
		//List intermediateCode = ax.getIntermediateCode ();
		//finalCodeFactory.create (intermediateCode);

		// En caso de no comentarse las dos sentencias anteriores se puede generar una excepcion
		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
		// aún no se tendrá implementada la generación de código intermedio ni final.
		// Para la entrega final deberán descomentarse y usarse.
		List<ScopeIF> scopesList = scopeManager.getAllScopes(); // for debugging purposes
		for (int j = 0; j < scopesList.size(); j++){
			ScopeIF current = scopesList.get(j);
			List myList = new ArrayList<TypeIF>(current.getTypeTable().getTypes());
			for (int i = 0; i < myList.size(); i++){
				System.out.println(myList.get(i));
			}
			List myList2 = new ArrayList<SymbolIF>(current.getSymbolTable().getSymbols()); 
			for (int i = 0; i < myList2.size(); i++){
				System.out.println(myList2.get(i));
			}
		}
		scopeManager.closeScope();
		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
	:};

axiom ::= 
{:
	scopeManager.openScope("global");
	scopeManager.getCurrentScope().getTypeTable().addType(new TypeSimple(scopeManager.getCurrentScope(), "vacio"));
	scopeManager.getCurrentScope().getTypeTable().addType(new TypeSimple(scopeManager.getCurrentScope(), "entero"));
:}
	seccionConstantes seccionTipos  axiom1;

axiom1 ::= seccionVariables seccionFunciones  | seccionFunciones;

seccionConstantes ::= declaracionConstante seccionConstantes
	| epsilon;     
                      
declaracionConstante ::= CONSTANTE IDENTIFICADOR:name NUMERO:value SEMI_COLON
{:
	checkIfExistsSymbolWithinOpenScopes(name, false);
	SymbolConstant<Integer> newSymbol = new SymbolConstant<Integer>(scopeManager.getCurrentScope(), name.getLexema(), scopeManager.searchType("entero"), Integer.parseInt(value.getLexema()));
	scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
:};

seccionTipos ::= declaracionTipo seccionTipos
	| epsilon;
                      
declaracionTipo ::= TIPO ENTERO IDENTIFICADOR:identifier OPEN_BRACKET tamTipo:tamTipo CLOSE_BRACKET SEMI_COLON
{:
	checkIfExistsTypeWithinOpenScopes(identifier, false);
	TypeArray typeArray = new TypeArray(scopeManager.getCurrentScope(), identifier.getLexema(), Integer.parseInt(tamTipo.getValue()));
	scopeManager.getCurrentScope().getTypeTable().addType(typeArray);
:};

tamTipo ::= NUMERO:n
{:
	if (Integer.parseInt(n.getLexema()) <= 0){ // if it is not positive
		semanticErrorManager.semanticFatalError("Linea " + n.getLine() + " Columna " + n.getColumn() + " valor " + n.getLexema() + " fuera del rango");
	}
	TamTipo tamTipo = new TamTipo(n.getLexema());
	RESULT = tamTipo;
:}
	| IDENTIFICADOR:s
{:
	SymbolIF symbol = checkIfExistsSymbolWithinOpenScopes(s, true);
	if (!symbol.getType().getName().equals("entero")){ // if it exists but it is not an integer
		semanticErrorManager.semanticFatalError("Linea " + s.getLine() + " Columna " + s.getColumn() + " objeto " + s.getLexema() + " no es de tipo entero");
	}
	String value = ((SymbolConstant)symbol).getValue().toString();
	if (Integer.parseInt(value) <= 0){ // if it exists and it is an integer but it is not positive
		semanticErrorManager.semanticFatalError("Linea " + s.getLine() + " Columna " + s.getColumn() + " valor " + s.getLexema() + " fuera del rango");
	}
	TamTipo tamTipo = new TamTipo(((SymbolConstant)symbol).getValue().toString());
	RESULT = tamTipo;
:};

seccionVariables ::= seccionVariables declaracionVariable | declaracionVariable;

declaracionVariable ::= ENTERO:identifier listadoIDs:list SEMI_COLON
{:
	for (int i = 0; i < list.size(); i++){
		SymbolVariable<Integer> newSymbol = list.get(i).hasAssignmentValue() ?
			new SymbolVariable(scopeManager.getCurrentScope(), list.get(i).getName(), scopeManager.searchType("entero"), list.get(i).getValue()) :
			new SymbolVariable(scopeManager.getCurrentScope(), list.get(i).getName(), scopeManager.searchType("entero"), null);
		scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
	}
:}
	| IDENTIFICADOR:identifier listadoIDs:list SEMI_COLON
{:
	TypeIF type = checkIfExistsTypeWithinOpenScopes(identifier, true);
	for (int i = 0; i < list.size(); i++){
		if (list.get(i).hasAssignmentValue()){ // if is being tried to be assigned
			semanticErrorManager.semanticFatalError("Linea " + identifier.getLine() + " " + list.get(i).getName() + " no puede ser inicializado");
		}
		SymbolVariable<ArrayList> newSymbol = new SymbolVariable(scopeManager.getCurrentScope(), list.get(i).getName(), type, null);
		scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
	}
:};
                      
listadoIDs ::= id:fullDeclaration listadoIDs1:restOfDeclarations
{:
	restOfDeclarations.add(fullDeclaration);
	RESULT = restOfDeclarations;
:};

listadoIDs1 ::= COLON listadoIDs:list
{:
	RESULT = list;
:}
	| epsilon
{:
	ArrayList<Id> emptyList = new ArrayList();
	RESULT = emptyList;
:};

id ::= IDENTIFICADOR:identifier id1:declaration
{:
	checkIfExistsSymbolWithinOpenScopes(identifier, false);
	Id fullDeclaration = new Id (identifier.getLexema(), declaration.hasAssignmentValue(), declaration.getValue());
	RESULT = fullDeclaration;
:};

id1 ::= epsilon
{:
	Id1 declaration = new Id1(false, 0);
	RESULT = declaration;
:}
    | ASSIGN NUMERO:n
{:
	Id1 declaration = new Id1(true, Integer.parseInt(n.getLexema()));
	RESULT = declaration;
:};

seccionFunciones ::= funcion seccionFunciones
                      | funcionPrincipal;
                      
funcion ::= VACIO IDENTIFICADOR:identifier  OPEN_KEY seccionParametros:params CLOSE_KEY {:
	checkIfExistsSymbolWithinOpenScopes(identifier,  false);
	SymbolProcedure newSymbol = new SymbolProcedure(scopeManager.getCurrentScope(), identifier.getLexema(), scopeManager.searchType("vacio"), params);
	scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
:}
OPEN_PARENTHESIS
{:
	scopeManager.openScope();
	for (int i = 0; i < params.size(); i++){
		TypeIF type = params.get(i).getType();
		SymbolParameter<?> newSymbol = new SymbolParameter<>(scopeManager.getCurrentScope(), params.get(i).getName(), params.get(i).getType(), null);
		scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
	}:}
seccionTipos funcion1:list {:
	checkIfReturnTypesMatch(list, "VACIO", Integer.toString(identifier.getLine()));
:}
	| ENTERO IDENTIFICADOR:identifier  OPEN_KEY seccionParametros:params CLOSE_KEY {:
	checkIfExistsSymbolWithinOpenScopes(identifier, false);
	SymbolFunction newSymbol = new SymbolFunction(scopeManager.getCurrentScope(), identifier.getLexema(), scopeManager.searchType("entero"), params);
	scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
:}
OPEN_PARENTHESIS {:
	scopeManager.openScope();
	for (int i = 0; i < params.size(); i++){
		TypeIF type = params.get(i).getType();
		SymbolParameter<?> newSymbol = new SymbolParameter<>(scopeManager.getCurrentScope(), params.get(i).getName(), params.get(i).getType(), null);
		scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
	}
:}
seccionTipos funcion1:list {:
	checkIfReturnTypesMatch(list, "entero", Integer.toString(identifier.getLine()));
:};
               
funcion1 ::= listadoSentencias:list CLOSE_PARENTHESIS:p
{:
	checkIfContainsReturn(list, Integer.toString(p.getLine()));
	scopeManager.closeScope();
	RESULT = list;
:}
  | seccionVariables listadoSentencias:list CLOSE_PARENTHESIS:p
{:
	checkIfContainsReturn(list, Integer.toString(p.getLine()));
	scopeManager.closeScope();
	RESULT = list;
:};

seccionParametros ::= declaracionParametros:params
{:
	RESULT = params;
:} 
	| epsilon
{:
	ArrayList<Parametro> params = new ArrayList();
	RESULT = params;
:};

declaracionParametros ::= parametro:param
{:
	ArrayList<Parametro> params = new ArrayList();
	params.add(param);
	RESULT = params;
:}
	| parametro:param COLON declaracionParametros:params
{:
	params.add(param);
	RESULT = params;
:};

parametro ::= ENTERO IDENTIFICADOR:name
{:
	Parametro param = new Parametro(scopeManager.searchType("entero"), name.getLexema());
	RESULT = param;
:}
	| IDENTIFICADOR:identifier IDENTIFICADOR:name
{:
	TypeIF type = checkIfExistsTypeWithinOpenScopes(identifier, true);
	Parametro param = new Parametro(type, name.getLexema());
	RESULT = param;
:};

funcionPrincipal ::= VACIO principal:p OPEN_KEY CLOSE_KEY OPEN_PARENTHESIS {:
	scopeManager.openScope("main");
:} funcionPrincipal1:list {:
	checkIfContainsReturn(list, Integer.toString(p.getLine()));
	checkIfReturnTypesMatch(list, "VACIO", Integer.toString(p.getLine()));
	SymbolProcedure newSymbol = new SymbolProcedure(scopeManager.getCurrentScope(), p.getLexema(), scopeManager.searchType("vacio"), new ArrayList<Parametro>());
	scopeManager.getCurrentScope().getSymbolTable().addSymbol(newSymbol);
:} ;

funcionPrincipal1 ::= seccionVariables listadoSentencias:list CLOSE_PARENTHESIS {:
	scopeManager.closeScope();
	RESULT = list;
:}	| listadoSentencias:list CLOSE_PARENTHESIS
{:
	scopeManager.closeScope();
	RESULT = list;
:};


// EXPRESIONES

expresion ::= NUMERO:n {:
	Expresion e = new Expresion(scopeManager.searchType("entero"), "constante", Integer.parseInt(n.getLexema()));
	RESULT = e;
:}	| IDENTIFICADOR:id {:
	SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
	String subTipo = mySymbol.getClass() == SymbolConstant.class ? "constante" : "variable";
	Object value = subTipo.equals("constante") ? ((SymbolConstant)mySymbol).getValue() : null;
	Expresion e = new Expresion(mySymbol.getType(), subTipo, value);
	RESULT = e;
:}	|  OPEN_KEY expresion:e CLOSE_KEY {:
	RESULT = e;
:}	|  expresion:a PLUS:p expresion:b {:
	if (!a.getType().getName().equals("entero") || !b.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresiones deben ser de tipo int");
	}
	String subTipo = a.getSubType().equals("constante") && b.getSubType().equals("constante") ? "constante" : "variable";
	Object value = subTipo.equals("constante") ? Integer.parseInt(a.getValue().toString()) + Integer.parseInt(b.getValue().toString()) : null;
	Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
	RESULT = e;
:}	|  expresion:a MULT:p expresion:b {:
	if (!a.getType().getName().equals("entero") || !b.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresiones deben ser de tipo int");
	}
	String subTipo = a.getSubType().equals("constante") && b.getSubType().equals("constante") ? "constante" : "variable";
	Object value = subTipo.equals("constante") ? Integer.parseInt(a.getValue().toString()) * Integer.parseInt(b.getValue().toString()) : null;
	Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
	RESULT = e;
:} 	|  expresion:a AUTO_INCREMENTO:p {:
	if (!a.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresion debe ser de tipo int");
	}
	String subTipo = a.getSubType().equals("constante") ? "constante" : "variable";
	Object value = subTipo.equals("constante") ? Integer.parseInt(a.getValue().toString()) + 1 : null;
	Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
	RESULT = e;
:} 	|  NEGACION:p expresion:a {:
	if (!a.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresion debe ser de tipo int");
	}
	String subTipo = a.getSubType().equals("constante") ? "constante" : "variable";
	Object value;
	if (subTipo.equals("constante")){
		value = Integer.parseInt(a.getValue().toString()) == 0 ? 1 : 0;
	} else {
		value = null;
	}
	Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
	RESULT = e;
:}
 	|  expresion:a LOWER_THAN:p expresion:b {:
	if (!a.getType().getName().equals("entero") || !b.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresiones deben ser de tipo int");
	}
	String subTipo = a.getSubType().equals("constante") && b.getSubType().equals("constante") ? "constante" : "variable";
	Object value;
	if (subTipo.equals("constante")){
		value = Integer.parseInt(a.getValue().toString()) < Integer.parseInt(b.getValue().toString()) ? 1 : 0;
	} else {
		value = null;
	}
	Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
	RESULT = e;
:}
 	|  expresion:a EQUAL:p expresion:b {:
	if (!a.getType().getName().equals("entero") || !b.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresiones deben ser de tipo int");
	}
	String subTipo = a.getSubType().equals("constante") && b.getSubType().equals("constante") ? "constante" : "variable";
	Object value;
	if (subTipo.equals("constante")){
		value = Integer.parseInt(a.getValue().toString()) == Integer.parseInt(b.getValue().toString()) ? 1 : 0;
	} else {
		value = null;
	}
	Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
	RESULT = e;
:}
 	|  expresion:a AND_LOGICA:p expresion:b {:
	if (!a.getType().getName().equals("entero") || !b.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + p.getLine() + " Columna " + p.getColumn() + " expresiones deben ser de tipo int");
	}
	String subTipo = a.getSubType().equals("constante") && b.getSubType().equals("constante") ? "constante" : "variable";
	Object value;
	if (subTipo.equals("constante")){
		value = Integer.parseInt(a.getValue().toString()) < Integer.parseInt(b.getValue().toString()) ? 1 : 0;
	} else {
		value = null;
	}
	Expresion e = new Expresion(scopeManager.searchType("entero"), subTipo, value);
	RESULT = e;
:}
 	|  accesoVector{:
	Expresion e = new Expresion(scopeManager.searchType("entero"), "variable", null);
	RESULT = e;
:}
 	|  llamadaFuncion:name {:
	SymbolIF mySymbol = scopeManager.searchSymbol(name);
	Expresion e = new Expresion(mySymbol.getType(), "variable", null);
	RESULT = e;
:};

accesoVector ::= IDENTIFICADOR:id OPEN_BRACKET expresion:e  CLOSE_BRACKET {:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " expresion indice debe ser de tipo int");
	}
	SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
	Class<?> classOfType = mySymbol.getType().getClass();
	if (classOfType != TypeArray.class){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " identificador " + mySymbol.getName() + " no es un vector");
	}
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " identificador " + mySymbol.getName() + " no es un vector");
	}
	if (e.getSubType().equals("constante")){
		int maxLength = ((TypeArray)mySymbol.getType()).getLength();
		int index = (int)e.getValue();
		if (index < 0 || index >= maxLength){
			semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " expresion con valor " + index +" fuera de rango 0-" + maxLength);
		}
	}
:};

sentenciaLlamadaFuncion ::= llamadaFuncion SEMI_COLON;

llamadaFuncion ::= IDENTIFICADOR:id OPEN_KEY parametros:list CLOSE_KEY {:
	SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
	Class<?> classOfSymbol = mySymbol.getClass();
	if (classOfSymbol != SymbolFunction.class && classOfSymbol != SymbolProcedure.class){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " identificador " + mySymbol.getName() + " no es una funcion");
	}
	ArrayList<Parametro> listaOriginal = new ArrayList();
	if (classOfSymbol == SymbolFunction.class){
		listaOriginal = ((SymbolFunction)mySymbol).getParameters();
	} else {
		listaOriginal = ((SymbolProcedure)mySymbol).getParameters();
	}
	if (listaOriginal.size() != list.size()){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " funcion " + mySymbol.getName() + " parametros esperados " + listaOriginal.size() + " parametros obtenidos " + list.size());
	}
	for (int i = 0; i < list.size(); i++){
		if (!list.get(i).getType().getName().equals(listaOriginal.get(i).getType().getName())){
			semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " funcion " + mySymbol.getName() + " parametro " + (list.size() - i) + " tipo esperado " + listaOriginal.get(i).getType().getName() + " tipo obtenido " + list.get(i).getType().getName());
		}
	}
	RESULT = id.getLexema();
:}	| IDENTIFICADOR:id OPEN_KEY CLOSE_KEY {:
	SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
	Class<?> classOfSymbol = mySymbol.getClass();
	if (classOfSymbol != SymbolFunction.class && classOfSymbol != SymbolProcedure.class){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " + id.getColumn() + " identificador " + mySymbol.getName() + " no es una funcion");
	}
	ArrayList<Parametro> listaOriginal = new ArrayList();
	if (classOfSymbol == SymbolFunction.class){
		listaOriginal = ((SymbolFunction)mySymbol).getParameters();
	} else {
		listaOriginal = ((SymbolProcedure)mySymbol).getParameters();
	}
	ArrayList<Parametro> list = new ArrayList<Parametro>();
	if (listaOriginal.size() != list.size()){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " funcion " + mySymbol.getName() + " parametros esperados " + listaOriginal.size() + " parametros obtenidos " + list.size());
	}
	RESULT = id.getLexema();
:};

parametros ::= expresion:e {:
	ArrayList<Expresion> list = new ArrayList<Expresion>();
	list.add(e);
	RESULT = list;
:}  | expresion:e COLON parametros:list {:
	list.add(e);
	RESULT = list;	
:};

//  SENTENCIAS

bloque ::= OPEN_PARENTHESIS{:
	scopeManager.openScope();
:} bloque1;

bloque1 ::= seccionVariables listadoSentencias CLOSE_PARENTHESIS {:
	scopeManager.closeScope();
:}	| listadoSentencias CLOSE_PARENTHESIS{:
	scopeManager.closeScope();
:};

listadoSentencias ::= listadoSentencias:list sentencia:s
{:
	list.add(s);
	RESULT = list;
:}
	| sentencia:s
{:
	ArrayList<Sentencia> list= new ArrayList<Sentencia>();
	list.add(s);
	RESULT = list;
:};

sentencia ::= sentenciaDevuelve:sentencia
{:
	RESULT = sentencia;
:}
	| sentenciaIncremento
{:
	Sentencia sentencia = new Sentencia ("INCREMENTO");
	RESULT = sentencia;
:}
	| sentenciaAsignacion
{:
	Sentencia sentencia = new Sentencia ("ASIGNACION");
	RESULT = sentencia;
:}
	| sentenciaAsignacionSuma
{:
	Sentencia sentencia = new Sentencia ("ASIGNACIONSUMA");
	RESULT = sentencia;
:}
	| sentenciaSi
{:
	Sentencia sentencia = new Sentencia ("SI");
	RESULT = sentencia;
:}
	| sentenciaAlternativas
{:
	Sentencia sentencia = new Sentencia ("ALTERNATIVAS");
	RESULT = sentencia;
:}
	| sentenciaMientras
{:
	Sentencia sentencia = new Sentencia ("MIENTRAS");
	RESULT = sentencia;
:}
	| sentenciaLlamadaFuncion
{:
	Sentencia sentencia = new Sentencia ("LLAMADAFUNCION");
	RESULT = sentencia;
:}
	| sentenciaSalida
{:
	Sentencia sentencia = new Sentencia ("SALIDA");
	RESULT = sentencia;
:}
	| bloque
{:
	Sentencia sentencia = new Sentencia ("BLOQUE");
	RESULT = sentencia;
:};

sentenciaDevuelve ::= DEVUELVE SEMI_COLON {:
	Sentencia sentencia = new Sentencia ("DEVUELVE_VACIO");
	RESULT = sentencia;
:}	| DEVUELVE expresion:e SEMI_COLON {:	
	Sentencia sentencia = new Sentencia ("DEVUELVE_" + e.getType().getName());
	RESULT = sentencia;
:};

sentenciaIncremento ::= IDENTIFICADOR:id AUTO_INCREMENTO SEMI_COLON{:
	SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
	if (!mySymbol.getType().getName().equals("entero")) {
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " Columna " +id.getColumn() + " no se puede aplicar autoincremento a objeto no de tipo entero");
	}
:};

sentenciaAsignacion ::= ref:typeOfRef ASSIGN:a expresion:e SEMI_COLON{:
	if (!e.getType().getName().equals(typeOfRef)){
		semanticErrorManager.semanticFatalError("Linea " + a.getLine() + " no se puede asignar un " + e.getType().getName() + " a un " + typeOfRef);
	}
:};

sentenciaAsignacionSuma ::= ref:typeOfRef ASSIGN_SUMA:a expresion:e SEMI_COLON {:
	if (!e.getType().getName().equals(typeOfRef)){
		semanticErrorManager.semanticFatalError("Linea " + a.getLine() + " no se puede añadir un " + e.getType().getName() + " a un " + typeOfRef);
	}
:};

ref ::= IDENTIFICADOR:id {:
	SymbolIF mySymbol = checkIfExistsSymbolWithinOpenScopes(id, true);
	if (!mySymbol.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " el objeto " + id.getLexema() + " no es de tipo entero");
	}
	RESULT = mySymbol.getType().getName();
:} | accesoVector {:
	RESULT = "entero";
:};

sentenciaSi ::= SI:id OPEN_KEY expresion:e CLOSE_KEY sentencia SINO sentencia {:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " expresion no se puede evaluar a 0 u otro entero");
	}
:}
	 | SI:id OPEN_KEY expresion:e CLOSE_KEY sentencia {:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " expresion no se puede evaluar a 0 u otro entero");
	}
:};
	
sentenciaAlternativas ::= ALTENATIVAS:id OPEN_KEY expresion:e {:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " la expresion no se puede evaluar a un entero");
	}
:} CLOSE_KEY OPEN_PARENTHESIS casosAlternativa porDefecto CLOSE_PARENTHESIS;

casosAlternativa ::= casosAlternativa casoAlt | casoAlt;

casoAlt ::= CASO NUMERO TWO_POINTS bloque CORTE SEMI_COLON;

porDefecto ::= PORDEFECTO TWO_POINTS bloque CORTE SEMI_COLON | epsilon; 

sentenciaMientras ::= MIENTRAS:id OPEN_KEY expresion:e {:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " la expresion no se puede evaluar a 0 u otro entero");
	}
:} CLOSE_KEY sentencia;

sentenciaSalida ::= ESCRIBE OPEN_KEY opcionesEscribe CLOSE_KEY SEMI_COLON
	| ESCRIBE_ENT:id OPEN_KEY opcionesEscribeEnt:e{:
	if (!e.getType().getName().equals("entero")){
		semanticErrorManager.semanticFatalError("Linea " + id.getLine() + " la expresion no se puede evaluar a entero");
	}
	:} CLOSE_KEY SEMI_COLON;

opcionesEscribe ::= epsilon | STRING;

opcionesEscribeEnt ::= epsilon | expresion:e {:
	RESULT = e;
:};
